<빅오(O) 표기법>
빅오(Big O) 표기법은 알고리즘의 성능을 분석할 때 사용하는 수학적 표현 방식이다.
이는 특히 알고리즘이 처리해야할 데이터의 양이 증가할 때, 그 알고리즘이 얼마나 빠르게 실행되는지 나타낸다.
여기서 중요한 것은 알고리즘의 정확한 실행 시간을 계산하는 것이 아니라, 데이터 양의 증가에 따른 성능의 변화 추세를 이해하는 것이다.

**빅오 표기법의 예시**
**O(1)** - 상수 시간: 입력 데이터의 크기에 관계없이 알고리즘의 실행 시간이 일정한다.
예) 배열에서 인덱스를 사용하는 경우

**O(n)** - 선형 시간: 알고리즘의 실행 시간이 입력 데이터의 크기에 비례하여 증가한다.
예) 배열의 검색, 배열의 모든 요소를 순회하는 경우

**O(n²)** - 제곱 시간: 알고리즘의 실행 시간이 입력 데이터의 크기의 제곱에 비례하여 증가한다.
n²은 `n * n` 을 뜻한다.
예) 보통 이중 루프를 사용하는 알고리즘에서 나타남

**O(log n)** - 로그 시간: 알고리즘의 실행 시간이 데이터 크기의 로그에 비례하여 증가한다.
예) 이진 탐색

**O(n log n)** - 선형 로그 시간:
예) 많은 효율적인 정렬 알고리즘들


**참고**
복잡하고 어려운 수학을 이야기하려는 것이 아니다. `log` 는 뒤에서 다시 설명하니 이런 것이 있다고 참고만 하고 넘어가자.
빅오 표기법은 매우 큰 데이터를 입력한다고 가정하고, 데이터 양 증가에 따른 성능의 변화 추세를 비교하는데 사용한다.
쉽게 이야기해서 정확한 성능을 측정하는 것이 목표가 아니라 매우 큰 데이터가 들어왔을 때의 대략적인 추세를 비교를 하는 것이 목적이다.
따라서 데이터가 매우 많이 들어오면 추세를 보는데 상수는 크게 의미가 없어진다.
이런 이유로 빅오 표기법에서는 상수를 제거한다. 예를 들어 O(n + 2), O(n/2)도 모두 O(n)으로 표시한다.
빅오 표기법은 별도의 이야기가 없으면 보통 최악의 상황을 가정해서 표기한다. 물론 최적, 평균, 최악의 경우로 나누어 표기하는 경우도 있다.

예를 들어서 앞서 살펴본 배열의 순차 검색의 경우를 나누어 살펴보자.
**최적의 경우**: 배열의 첫번째 항목에서 바로 값을 찾으면 O(1)이 된다.
**최악의 경우**: 마지막 항목에 있거나 항목이 없는 경우 전체 요소를 순회한다. 이 경우 O(n)이 된다.
**평균의 경우**: 평균적으로 보면 보통 중간쯤 데이터를 발견하게 된다. 이 경우 O(n/2)가 되지만, 상수를 제외해서
O(n)으로 표기한다. 최악과 비교를 위해 O(n/2)로 표기하는 경우도 있다.
배열의 인덱스를 사용하면 데이터의 양과 관계 없이 원하는 결과를 한번에 찾기 때문에 항상 O(1)이 된다.

**배열 정리**
배열의 인덱스 사용: O(1)
배열의 순차 검색: O(n)
배열에 데이터가 100,000건이 있다면 인덱스를 사용하면 1번의 연산으로 결과를 찾을 수 있지만, 순차 검색을 사용한다면 최악의 경우 100,000번의 연산이 필요하다.
배열에 들어있는 데이터의 크기가 증가할 수록 그 차이는 매우 커진다.
따라서 인덱스를 사용할 수 있다면 최대한 활용하는 것이 좋다.


<직접 구현하는 배열 리스트1 - 시작>
배열의 경우 다음 2가지 불편함이 있다.
1.배열의 길이를 동적으로 변경할 수 없다.
2.데이터를 추가하기 불편하다.
데이터를 추가하는 경우 직접 오른쪽으로 한 칸씩 데이터를 밀어야 한다. (이런 코드를 직접 작성해야 한다.)
배열의 이런 불편함을 해소하고 동적으로 데이터를 추가할 수 있는 자료 구조를 List(리스트)라 한다.

**List 자료 구조**
순서가 있고, 중복을 허용하는 자료 구조를 리스트라 한다.
일반적으로 배열과 리스트는 구분해서 이야기한다. 리스트는 배열보다 유연한 자료 구조로, 크기가 동적으로 변할 수 있다.

**배열**: 순서가 있고 중복을 허용하지만 크기가 정적으로 고정된다.
**리스트**: 순서가 있고 중복을 허용하지만 크기가 동적으로 변할 수 있다.

여기서 중복을 허용한다는 뜻은 같은 데이터를 입력할 수 있다는 것이다. 예를 들어서 `arr[0] = 1` , `arr[1] = 1`은 하나의 배열에 같은 숫자 `1` 이 입력되었다.
이것이 중복을 허용한다는 뜻이다. 자료 구조 중에는 중복을 허용하지 않는 자료 구조도 존재한다.


<직접 구현하는 배열 리스트5 - 제네릭2>
**Object 배열을 사용한 이유**
`Object[] elementData` 을 그대로 사용하는 이유
제네릭은 런타임에 이레이저에 의해 타입 정보가 사라진다. 따라서 런타임에 타입 정보가 필요한 생성자에 사용할 수 없다.
따라서 제네릭을 기반으로 배열을 생성하는 다음 코드는 작동하지 않고, 컴파일 오류가 발생한다.

참고로 이것은 자바가 제공하는 제네릭의 한계이다.
`new E[DEFAULT_CAPACITY]`
대신에 다음과 같이 모든 데이터를 담을 수 있는 `Object` 를 그대로 사용해야 한다.
`new Object[DEFAULT_CAPACITY]`
이렇게 `Object[]` 을 생성해서 사용해도 해도 문제가 없는지, 이 부분을 조금 더 살펴보자.
`new MyArrayListV4<String>` 을 사용한 경우 `E` 가 다음과 같이 처리된다.

**제네릭 타입 인자 적용 전**
```java
Object[] elementData;
void add(E e) {
elementData[size] = e;
...
}
E get(int index) {
return (E) elementData[index];
}


**제네릭 타입 인자 적용 후**
```
```java
Object[] elementData;
void add(String e) {
elementData[size] = e;
...
}
String get(int index) {
return (String) elementData[index];
}
```
`elementData[]` 에 데이터를 보관하는 `add(E e)` 메서드를 보자. `E` 타입으로 데이터를 입력한다.
`elementData[]` 에 데이터를 조회하는 `get()` 메서드를 보자. 보관할 때와 같은 `E` 타입으로 데이터를 다운 캐스팅 해서 반환한다.
따라서 배열의 모든 데이터는 `E` 타입으로 보관된다. 그리고 `get()`으로 배열에서 데이터를 꺼낼 때
`(E)`로 다운 캐스팅해도 보관한 `E` 타입으로 다운 캐스팅하기 때문에 아무런 문제가 되지 않는다.

더 구체적인 예를 들어보자.
`MyArrayListV4` 를 생성할 때 타입 매개변수 `E` 를 `String`으로 지정했다면 `elementData` 에는 항상 `String` 이 저장된다.
`add(String e)` 에서 배열의 모든 데이터는 `String` 타입으로 보관된다.
`get()` 에서 데이터를 꺼낼 때 항상 `(String)`로 다운 캐스팅 한다.
저장한 `String` 타입으로 다운 캐스팅 하기 때문에 아무런 문제가 되지 않는다.
`Object` 는 모든 데이터를 담을 수 있기 때문에 데이터를 담는데는 아무런 문제가 없다.
다만 데이터를 조회할 때 문제가 될 수 있는데, 이때는 조회한 `Object` 타입을 지정한 타입 매개변수로 다운캐스팅 해준다.

```java
public E get(int index) {
return (E) elementData[index];
}
```

`elementData[index]`로 조회한 결과는 `Object` 이다. 따라서 `(E) Object` 가 된다.
이렇게해도 문제가 없다. 우리가 `add(E e)` 를 통해 `Object elementData[]` 에 보관한 모든 데이터는 `E`
타입이라는 것이 확실하기 때문이다.
`E` 가 `String` 인 경우 `(String) Object` 이 된다.
정리하면 생성자에는 제네릭의 타입 매개변수를 사용할 수 없는 한계가 있다. 따라서 배열을 생성할 때 대안으로 Object 배열을 사용해야 한다.
하지만 제네릭이 리스트의 데이터를 입력 받고 반환하는 곳의 타입을 고정해준다.
따라서 고정된 타입으로 Object 배열에 데이터를 보관하고, 또 데이터를 꺼낼 때도 같은 고정된 타입으로 안전하게 다운 캐스팅 할 수 있다.

**MyArrayList의 단점**
**배열을 사용한 리스트인 MyArrayList는 다음과 같은 단점이 있다.**
정확한 크기를 미리 알지 못하면 메모리가 낭비된다. 배열을 사용하므로 배열 뒷 부분에 사용되지 않고, 낭비되는 메모리가 있다.
데이터를 중간에 추가하거나 삭제할 때 비효율적이다.
이 경우 데이터를 한 칸씩 밀어야 한다. 이것은 O(n)으로 성능이 좋지 않다.
만약 데이터의 크기가 1,000,000건이라면 최악의 경우 데이터를 추가할 때 마다 1,000,000건의 데이터를 밀어야 한다.

**ArrayList의 빅오 정리**
데이터 추가
마지막에 추가: O(1)
앞, 중간에 추가: O(n)

데이터 삭제
마지막에 삭제: O(1)
앞, 중간에 삭제: O(n)
인덱스 조회: O(1)
데이터 검색: O(n)