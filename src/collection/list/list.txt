**전략 패턴(Strategy Pattern)**
디자인 패턴 중에 가장 중요한 패턴을 하나 뽑으라고 하면 전략 패턴을 뽑을 수 있다.
전략 패턴은 알고리즘을 클라이언트 코드의 변경 없이 쉽게 교체할 수 있다.
방금 설명한 코드가 바로 전략 패턴을 사용한 코드이다.

`MyList` 인터페이스가 바로 전략을 정의하는 인터페이스가 되고, 각각의 구현체인 `MyArrayList` ,`MyLinkedList` 가 전략의 구체적인 구현이 된다.
그리고 전략을 클라이언트 코드(`BatchProcessor` )의 변경없이 손쉽게 교체할 수 있다.


**직접 만든 배열 리스트와 연결 리스트 - 성능 비교 표**
기능              배열 리스트      연결 리스트
앞에 추가(삭제)  O(n) - 1369ms     O(1) - 2ms
평균 추가(삭제)  O(n) - 651ms      O(n) - 1112ms
뒤에 추가(삭제)  O(1) - 2ms        O(n) - 2195ms
인덱스 조회     O(1) - 1ms       O(n) - 평균 438ms
검색          O(n) - 평균 115ms   O(n) - 평균 492ms

**추가, 삭제**
배열 리스트는 인덱스를 통해 추가나 삭제할 위치를 O(1)로 빠르게 찾지만, 추가나 삭제 이후에 데이터를 한칸씩 밀어야 한다. 이 부분이 O(n)으로 오래 걸린다.
연결 리스트는 인덱스를 통해 추가나 삭제할 위치를 O(n)으로 느리게 찾지만, 실제 데이터의 추가는 간단한 참조변경으로 빠르게 O(1)로 수행된다.

**앞에 추가(삭제)**
배열 리스트: 추가나 삭제할 위치는 찾는데 O(1), 데이터를 한칸씩 이동 O(n)
연결 리스트: 추가나 삭제할 위치는 찾는데 O(1), 노드를 변경하는데 O(1)=> O(1)

**평균 추가(삭제)**
배열 리스트: 추가나 삭제할 위치는 찾는데 O(1), 인덱스 이후의 데이터를 한칸씩 이동 O(n/2) =>O(n)
연결 리스트: 추가나 삭제할 위치는 찾는데 O(n/2), 노드를 변경하는데 O(1) =>  O(n)

**뒤에 추가(삭제)**
배열 리스트: 추가나 삭제할 위치는 찾는데 O(1), 이동할 데이터 없음
연결 리스트: 추가나 삭제할 위치는 찾는데 O(n), 노드를 변경하는데 O(1) =>O(n)
**인덱스 조회**
배열 리스트: 배열에 인덱스를 사용해서 값을 O(1)로 찾을 수 있음
연결 리스트: 노드를 인덱스 수 만큼 이동해야함 O(n)
**검색**
배열 리스트: 데이터를 찾을 때 까지 배열을 순회 O(n)
연결 리스트: 데이터를 찾을 때 까지 노드를 순회 O(n)

**시간 복잡도와 실제 성능**
이론적으로 `MyLinkedList` 의 평균 추가(중간 삽입) 연산은 `MyArrayList` 보다 빠를 수 있다.
그러나 실제 성능은 요소의 순차적 접근 속도, 메모리 할당 및 해제 비용, CPU 캐시 활용도 등 다양한 요소에 의해 영향을 받는다.
`MyArrayList` 는 요소들이 메모리 상에서 연속적으로 위치하여 CPU 캐시 효율이 좋고, 메모리 접근 속도가 빠르다.

반면, `MyLinkedList` 는 각 요소가 별도의 객체로 존재하고 다음 요소의 참조를 저장하기 때문에 CPU 캐시 효율이 떨어지고,메모리 접근 속도가 상대적으로 느릴 수 있다
`MyArrayList` 의 경우 `CAPACITY` 를 넘어서면 배열을 다시 만들고 복사하는 과정이 추가된다.
하지만 한번에 2배씩 늘어나기 때문에 이 과정은 가끔 발생하므로, 전체 성능에 큰 영향을 주지는 않는다.

정리하면 이론적으로 `MyLinkedList` 가 평균 추가(중간 삽입)에 있어 더 효율적일 수 있지만,
현대 컴퓨터 시스템의 메모리 접근 패턴, CPU 캐시 최적화 등을 고려할 때 `MyArrayList` 가 실제 사용 환경에서 더 나은 성능을 보여주는 경우가 많다.


배열 리스트 vs 연결 리스트**
대부분의 경우 배열 리스트가 성능상 유리하다. 이런 이유로 실무에서는 주로 배열 리스트를 기본으로 사용한다.
만약 데이터를 앞쪽에서 자주 추가하거나 삭제할 일이 있다면 연결 리스트를 고려하자.

<자바 리스트>
**List 자료 구조**
순서가 있고, 중복을 허용하는 자료 구조를 리스트라 한다. 자바의 컬렉션 프레임워크가 제공하는 가장 대표적인 자료
구조가 바로 리스트이다. 리스트와 관련된 컬렉션 프레임워크는 다음 구조를 가진다.

**컬렉션 프레임워크 - 리스트**
**Collection 인터페이스**
`Collection` 인터페이스는 `java.util` 패키지의 컬렉션 프레임워크의 핵심 인터페이스 중 하나이다.
이 인터페이스는 자바에서 다양한 컬렉션, 즉 데이터 그룹을 다루기 위한 메서드를 정의한다.
`Collection` 인터페이스는 `List` ,`Set` , `Queue` 와 같은 다양한 하위 인터페이스와 함께 사용되며,
이를 통해 데이터를 리스트, 세트, 큐 등의 형태로 관리할 수 있다. 자세한 내용은 뒤에서 다룬다.

**List 인터페이스**
`List` 인터페이스는 `java.util` 패키지에 있는 컬렉션 프레임워크의 일부다. `List` 는 객체들의 순서가 있는 컬렉션을 나타내며, 같은 객체의 중복 저장을 허용한다.
이 리스트는 배열과 비슷하지만, 크기가 동적으로 변화하는 컬렉션을 다룰 때 유연하게 사용할 수 있다.
`List` 인터페이스는 `ArrayList` , `LinkedList` 와 같은 여러 구현 클래스를 가지고 있으며, 각 클래스는 `List` 인터페이스의 메서드를 구현한다.


<자바 ArrayList>
`java.util.ArrayList`
자바가 제공하는 `ArrayList` 는 우리가 직접 만든 `MyArrayList` 와 거의 비슷하다. 특징은 다음과 같다.

**자바 ArrayList의 특징**
배열을 사용해서 데이터를 관리한다.
기본 `CAPACITY` 는 10이다.(`DEFAULT_CAPACITY = 10` )
`CAPACITY` 를 넘어가면 배열을 50% 증가한다.
10 15 22 33 49로 증가한다. (최적화는 자바 버전에 따라 달라질 수 있다.)
메모리 고속 복사 연산을 사용한다.

`ArrayList` 의 중간 위치에 데이터를 추가하면, 추가할 위치 이후의 모든 요소를 한 칸씩 뒤로 이동시켜야한다.
자바가 제공하는 `ArrayList` 는 이 부분을 최적화 하는데, 배열의 요소 이동은 시스템 레벨에서 최적화된 메모리 고속 복사 연산을 사용해서 비교적 빠르게 수행된다.
참고로 `System.arraycopy()` 를 사용한다.

<자바 LinkedList>
`java.util.LinkedList`
자바가 제공하는 `LinkedList` 는 우리가 직접 만든 `MyLinkedList` 와 거의 비슷하다. 특징은 다음과 같다.

**자바의 LinkedList 특징**
이중 연결 리스트 구조
첫 번째 노드와 마지막 노드 둘다 참조


**직접 만든 배열 리스트와 연결 리스트 - 성능 비교 표

기능          배열 리스트           연결 리스트
앞에 추가(삭제) O(n) - 1369ms     O(1) - 2ms
평균 추가(삭제) O(n) - 651ms      O(n) - 1112ms
뒤에 추가(삭제) O(1) - 2ms        O(n) - 2195ms
인덱스 조회      O(1) - 1ms           O(n) - 평균 438ms
검색          O(n) - 평균 115ms          O(n) - 평균 492ms


**자바가 제공하는 배열 리스트와 연결 리스트 - 성능 비교 표

기능              배열 리스트              연결 리스트
앞에 추가(삭제)   O(n) - 106ms      O(1) - 2ms
평균 추가(삭제)   O(n) - 49ms       O(n) - 1116ms
뒤에 추가(삭제)   O(1) - 1ms        O(1) - 2ms
인덱스 조회      O(1) - 1ms           O(n) - 평균 439ms
검색          O(n) - 평균 104ms          O(n) - 평균 473ms


**추가, 삭제**
배열 리스트는 인덱스를 통해 추가나 삭제할 위치를 O(1)로 빠르게 찾지만, 추가나 삭제 이후에 데이터를 한칸씩
밀어야 한다. 이 부분이 O(n)으로 오래 걸린다.
연결 리스트는 인덱스를 통해 추가나 삭제할 위치를 O(n)으로 느리게 찾지만, 실제 데이터의 추가는 간단한 참조 변경으로 O(1)로 빠르게 수행된다.



**앞에 추가(삭제)**
배열 리스트: 추가나 삭제할 위치는 찾는데 O(1), 데이터를 한칸씩 이동 O(n) =>O(n)
연결 리스트: 추가나 삭제할 위치는 찾는데 O(1), 노드를 변경하는데 O(1) O(n)

**평균 추가(삭제)**
배열 리스트: 추가나 삭제할 위치는 찾는데 O(1), 인덱스 이후의 데이터를 한칸씩 이동 O(n/2)  =>O(n)
연결 리스트: 추가나 삭제할 위치는 찾는데 O(n/2), 노드를 변경하는데 O(1) => O(n)


**뒤에 추가(삭제)**
배열 리스트: 추가나 삭제할 위치는 찾는데 O(1), 이동할 데이터 없음 =>O(1)
연결 리스트: 추가나 삭제할 위치는 찾는데 O(1), 노드를 변경하는데 O(1) =>O(1)
참고로 자바가 제공하는 연결 리스트(`LinkedList` )는 마지막 위치를 가지고 있다.

**인덱스 조회**
배열 리스트: 배열에 인덱스를 사용해서 값을 O(1)로 찾을 수 있음
연결 리스트: 노드를 인덱스 수 만큼 이동해야함 O(n)

**검색**
배열 리스트: 데이터를 찾을 때 까지 배열을 순회 O(n)
연결 리스트: 데이터를 찾을 때 까지 노드를 순회 O(n)

**데이터를 추가할 때 자바 ArrayList가 직접 구현한 MyArrayList보다 빠른 이유**
자바의 배열 리스트는 이때 메모리 고속 복사를 사용하기 때문에 성능이 최적화된다.
메모리 고속 복사는 시스템에 따라 성능이 다르기 때문에 정확한 계산은 어렵지만 대략 O(n/10) 정도로 추정하자.
상수를 제거하면 O(n)이 된다. 하지만 메모리 고속 복사라도 데이터가 아주 많으면 느려진다.

**시간 복잡도와 실제 성능**
이론적으로 `LinkedList` 의 중간 삽입 연산은 `ArrayList` 보다 빠를 수 있다.
그러나 실제 성능은 요소의 순차적 접근 속도, 메모리 할당 및 해제 비용, CPU 캐시 활용도 등 다양한 요소에 의해 영향을 받는다.
추가로 `ArrayList` 는 데이터를 한 칸씩 직접 이동하지 않고, 대신에 메모리 고속 복사를 사용한다.
`ArrayList` 는 요소들이 메모리 상에서 연속적으로 위치하여 CPU 캐시 효율이 좋고, 메모리 접근 속도가 빠르다.

반면, `LinkedList` 는 각 요소가 별도의 객체로 존재하고 다음 요소의 참조를 저장하기 때문에 CPU 캐시 효율이 떨어지고, 메모리 접근 속도가 상대적으로 느려질 수 있다
`ArrayList` 의 경우 `CAPACITY` 를 넘어서면 배열을 다시 만들고 복사하는 과정이 추가된다.
하지만 한번에50%씩 늘어나기 때문에 이 과정은 가끔 발생하므로, 전체 성능에 큰 영향을 주지는 않는다.
정리하면 이론적으로 `LinkedList` 가 중간 삽입에 있어 더 효율적일 수 있지만,
현대 컴퓨터 시스템의 메모리 접근 패턴, CPU 캐시 최적화, 메모리 고속 복사 등을 고려할 때 `ArrayList` 가 실제 사용 환경에서 더 나은 성능을 보여주는 경우가 많다.


**배열 리스트 vs 연결 리스트**
대부분의 경우 배열 리스트가 성능상 유리하다. 이런 이유로 실무에서는 주로 배열 리스트를 기본으로 사용한다.
만약 데이터를 앞쪽에서 자주 추가하거나 삭제할 일이 있다면 연결 리스트를 고려하자.