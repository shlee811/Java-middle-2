<해시 알고리즘4 - 나머지 연산>
앞에서 이야기한 것 처럼 모든 숫자를 입력할 수 있다고 가정하면, 입력값의 범위가 너무 넓어져서 데이터의 값을 인덱스로 사용하기는 어렵다.
하지만 입력 값의 범위가 넓어도 해당 범위의 값을 모두 다 입력하는 것은 아니다.
앞의 예에서 0 ~ 99 범위의 값 중에 1, 2, 5, 8, 14, 99만 입력했다. 따라서 대부분의 공간은 낭비되었다.
공간도 절약하면서, 넓은 범위의 값을 사용할 수 있는 방법이 있는데, 바로 나머지 연산을 사용하는 것이다.
저장할 수 있는 배열의 크기(CAPACITY)를 10이라고 가정하자. 그 크기에 맞추어 나머지 연산을 사용하면 된다.

나머지 연산
`1 % 10 = 1`
`2 % 10 = 2`
`5 % 10 = 5`
`8 % 10 = 8`
`14 % 10 = 4`
`99 % 10 = 9`
여기서 14, 99는 10보다 큰 값이다. 따라서 일반적인 방법으로는 크기가 10인 배열의 인덱스로 사용할 수 없다.
하지만 나머지 연산의 결과를 사용하면 14는 4로, 99는 9로 크기가 10인 배열의 인덱스로 활용할 수 있다.
나머지 연산의 결과는 절대로 배열의 크기를 넘지 않는다. 예를 들어 나머지 연산에 10을 사용하면 결과는 `0~9` 까지만 나온다.
절대로 10이 되거나 10을 넘지 않는다. 따라서 연산 결과는 배열의 크기를 넘지 않으므로 안전하게 인덱스로 사용할 수 있다.

예)
`9 % 10 -> 9`
`10 % 10 -> 0`
`11 % 10 -> 1`


**해시 인덱스**
이렇게 배열의 인덱스로 사용할 수 있도록 원래의 값을 계산한 인덱스를 해시 인덱스(hashIndex)라 한다.
14의 해시 인덱스는 4, 99의 해시 인덱스는 9이다.
이렇게 나머지 연산을 통해 해시 인덱스를 구하고, 해시 인덱스를 배열의 인덱스로 사용해보자.

**해시 인덱스와 데이터 저장**
1, 2, 5, 8, 14 ,99의 값을 크기가 10인 배열에 저장해보자.

저장할 값에 나머지 연산자를 사용해서 해시 인덱스를 구한다.
`1 % 10 = 1`
`2 % 10 = 2`
`5 % 10 = 5`
`8 % 10 = 8`
`14 % 10 = 4`
`99 % 10 = 9`
해시 인덱스를 배열의 인덱스로 사용해서 데이터를 저장한다.
예) `inputArray[hashIndex] = value`
인덱스만 해시 인덱스를 사용하고, 값은 원래 값을 저장한다.
배열의 인덱스를 사용하기 때문에 하나의 값을 저장하는데 O(1)로 빠른 성능을 제공한다.
해시 인덱스 생성 O(1) + 해시 인덱스를 사용해 배열에 값 저장O(1)=> O(1)


**해시 인덱스와 데이터 조회**
조회할 값에 나머지 연산자를 사용해서 해시 인덱스를 구한다.
`2 % 10 = 2`
`14 % 10 = 4`
`99 % 10 = 9`
해시 인덱스를 배열의 인덱스로 사용해서 데이터를 조회한다.

예) `int value = inputArray[hashIndex]`
인덱스만 해시 인덱스를 사용하고, 값은 원래 값을 조회한다.
배열의 인덱스를 사용하기 때문에 하나의 값을 찾는데 O(1)로 빠른 성능을 제공한다.
해시 인덱스 생성 O(1) + 해시 인덱스를 사용해 배열에서 값 조회O(1)=> O(1)


<해시 알고리즘5 - 해시 충돌 설명>

**해시 충돌
99, 9의 두 값은 10으로 나누면 9가 된다. 따라서 다른 값을 입력했지만 같은 해시 코드가 나오게 되는데 이것을 해시 충돌이라 한다.
`99 % 10 = 9`
`9 % 10 = 9`

해시 충돌이 발생하면 어떤 문제가 나타나는지 알아보자.

먼저 99의 값을 저장한다. 해시 인덱스는 9이므로 9번 인덱스에 99 값을 저장한다.
다음으로 9의 값을 저장한다. 해시 인덱스는 9이므로 9번 인덱스에 9 값을 저장한다.
결과적으로 배열의 인덱스 9에는 처음에 저장한 값 99는 사라지고, 마지막에 저장한 값 9만 남게된다.
이 문제를 해결하는 가장 단순한 방법은 CAPACITY를 값의 입력 범위만큼 키우면 된다.
여기서는 99까지만 입력하므로 CAPACITY를 100으로 늘리면 된다. 그러면 충돌이 발생하지 않는다.
하지만 앞서 보았듯이 이 방법은 메모리 낭비가 심하고, 모든 `int` 숫자를 다 받는 문제를 해결할 수 없다.

**해시 충돌 해결**
해시 충돌을 인정하면 문제 해결의 실마리가 보인다.
해시 충돌은 낮은 확률로 일어날 수 있다고 가정하는 것이다.
해결 방안은 바로 해시 충돌이 일어났을 때 단순하게 같은 해시 인덱스의 값을 같은 인덱스에 함께 저장해버리는 것이다.

**해시 충돌과 저장**
물론 여러 데이터를 배열의 하나의 공간에 함께 저장할 수는 없다.
대신에 **배열 안에 배열을 만들면 된다**.
물론 배열 안에 리스트 같은 다른 자료구조를 사용해도 된다.

**해시 충돌과 조회**
해시 충돌이 난 경우 내부의 데이터를 하나씩 비교해보면 원하는 결과를 찾을 수 있다. 예를 들어 99를 조회한다고 가정 해보자.
99의 해시 인덱스는 9이다. 배열에서 9번 인덱스를 찾는다.

배열 안에는 또 배열이 들어있다. 여기에 있는 모든 값을 검색할 값과 하나씩 비교한다.
[99, 9]의 데이터가 들어있는데, 첫 비교해서 원하는 데이터를 찾을 수 있다.
9의 해시 인덱스는 9이다. 배열에서 9번 인덱스를 찾는다.
배열 안에는 또 배열이 들어있다. 여기에 있는 모든 값을 검색할 값과 하나씩 비교한다.
[99, 9]의 데이터가 들어있다. 첫 비교에서 `99 equals 9` 는 거짓이므로 실패한다. 다음 비교에서 `9equals 9` 이므로 원하는 데이터를 찾았다.
비교시 `equals` 를 사용했지만 기본형이라면 물론 `==` 을 사용해도 된다.

**최악의 경우**
값을 9, 19, 29, 99만 저장한다고 가정해보자. 이 경우 모든 해시 인덱스가 9가 된다.
따라서 9번 인덱스에 데이터가 모두 저장된다.
이렇게 되면 데이터를 찾을 때 결국 9번에 가서 저장한 데이터의 수 만큼 값을 반복해서 비교해야 한다.
따라서 최악의 경우 O(n)의 성능을 보인다.

**정리**
해시 인덱스를 사용하는 방식은 최악의 경우 O(n)의 성능을 보인다.
하지만 확률적으로 보면 어느 정도 넓게 퍼지기 때문에 평균으로 보면 대부분 O(1)의 성능을 제공한다.
해시 충돌이 가끔 발생해도 내부에서 값을 몇 번만 비교하는 수준이기 때문에 대부분의 경우 매우 빠르게 값을 찾을 수 있다.


<해시 인덱스 충돌 확률>
해시 충돌이 발생하면 데이터를 추가하거나 조회할 때, 연결 리스트 내부에서 O(n)의 추가 연산을 해야 하므로 성능이 떨어진다.
따라서 해시 충돌은 가급적 발생하지 않도록 해야 한다.
해시 충돌이 발생할 확률은 입력하는 데이터의 수와 배열의 크기와 관련이 있다.
입력하는 데이터의 수와 비교해서 배열의 크기가 클 수록 충돌 확률은 낮아진다.

배열의 크기인 `CAPACITY` 값을 변경하면서 실행해 보자.
**CAPACITY = 1**: `[[1, 2, 5, 8, 14, 99, 9]]`
**CAPACITY = 5**: `[[5], [1], [2], [8], [14, 99, 9]]`
**CAPACITY = 10**: `[[], [1], [2], [], [14], [5], [], [], [8], [99, 9]]`
**CAPACITY = 11**: `[[99], [1], [2], [14], [], [5], [], [], [8], [9], []]`
**CAPACITY = 15**: `[[], [1], [2], [], [], [5], [], [], [8], [99, 9], [], [], [], [],[14]]`
**CAPACITY = 1**: 배열의 크기가 하나밖에 없을 때는 모든 해시가 충돌한다.
**CAPACITY = 5**: 배열의 크기가 입력하는 데이터 수 보다 작은 경우 해시 충돌이 자주 발생한다.
**CAPACITY = 10**: 저장할 데이터가 7개 인데, 배열의 크기는 10이다. **7/10 약 70% 정도**로 약간 여유있게 데이터가 저장된다. 이 경우 가끔 충돌이 발생한다.
**CAPACITY = 11**: 저장할 데이터가 7개 인데, 배열의 크기는 11이다. 가끔 충돌이 발생한다. 여기서는 충돌이 발생하지 않았다.
**CAPACITY = 15**: 저장할 데이터가 7개 인데, 배열의 크기는 15이다. 가끔 충돌이 발생한다. 여기서는 충돌이 하나 발생했다.
아주 간단한 예제로 알아보았지만, 통계적으로 입력한 데이터의 수가 배열의 크기를 75% 넘지 않으면 해시 인덱스는 자주 충돌하지 않는다.
반대로 75%를 넘으면 자주 충돌하기 시작한다.
배열의 크기를 크게 만들면 해시 충돌은 줄어서 성능은 좋아지지만, 많은 메모리가 낭비된다.
반대로 배열의 크기를 너무 작게 만들면 해시가 자주 충돌해서 성능이 나빠진다.
상황에 따라 다르겠지만 보통 75%를 적절한 크기로 보고 기준 으로 잡는 것이 효과적이다.

**정리**
해시 인덱스를 사용하는 경우
데이터 저장
평균: O(1)
최악: O(n)
데이터 조회
평균: O(1)
최악: O(n)

해시 인덱스를 사용하는 방식은 사실 최악의 경우는 거의 발생하지 않는다.
배열의 크기만 적절하게 잡아주면 대부분 O(1)에 가까운 매우 빠른 성능을 보여준다.
이제 O(n)을 O(1)로 바꿀 수 있는 매우 효율적인 해시 알고리즘에 대해서 배웠다.
지금까지 설명한 내용을 바탕으로 `MyHashSetV0` 를 개선해보자.


<해시 코드와 해시 인덱스>
여기서는 `hashCode()` 라는 메서드를 통해서 문자를 기반으로 고유한 숫자를 만들었다. 이렇게 만들어진 숫자를 해시 코드라 한다.
여기서 만든 해시 코드는 숫자이기 때문에 배열의 인덱스로 사용할 수 있다. 전체 과정을 그림으로 살펴보자.
`hashCode()` 메서드를 사용해서 문자열을 해시 코드로 변경한다. 그러면 고유한 정수 숫자 값이 나오는데, 이것을 해시 코드라 한다.
숫자 값인 해시 코드를 사용해서 해시 인덱스를 생성한다.
이렇게 생성된 해시 인덱스를 배열의 인덱스로 사용하면 된다.

용어 정리
**해시 함수(Hash Function)**
해시 함수는 임의의 길이의 데이터를 입력으로 받아, 고정된 길이의 해시값(해시 코드)을 출력하는 함수이다.
여기서 의미하는 고정된 길이는 저장 공간의 크기를 뜻한다. 예를 들어서 `int` 형 `1` , `100` 은 둘다 4byte를 차지하는 고정된 길이는 뜻한다.
같은 데이터를 입력하면 항상 같은 해시 코드가 출력된다.
다른 데이터를 입력해도 같은 해시 코드가 출력될 수 있다. 이것을 해시 충돌이라 한다.

해시 충돌의 예
"BC" "AD" B(66) + C(67) = 133
A(65) + D(68) = 133

**해시 코드(Hash Code)**
해시 코드는 데이터를 대표하는 값을 뜻한다. 보통 해시 함수를 통해 만들어진다.
데이터 `A` 의 해시 코드는 `65`
데이터 `B` 의 해시 코드는 `66`
데이터 `AB` 의 해시 코드는 `131`

**해시 인덱스(Hash Index)**
해시 인덱스는 데이터의 저장 위치를 결정하는데, 주로 해시 코드를 사용해서 만든다.
보통 해시 코드의 결과에 배열의 크기를 나누어 구한다.
요약하면, 해시 코드는 데이터를 대표하는 값, 해시 함수는 이러한 해시 코드를 생성하는 함수,
그리고 해시 인덱스는 해시 코드를 사용해서 데이터의 저장 위치를 결정하는 값을 뜻한다.

**정리**
문자 데이터를 사용할 때도, 해시 함수를 사용해서 정수 기반의 해시 코드로 변환한 덕분에, 해시 인덱스를 사용할 수 있게 되었다.
따라서 문자의 경우에도 해시 인덱스를 통해 빠르게 저장하고 조회할 수 있다.
여기서 핵심은 해시 코드이다.

세상의 어떤 객체든지 정수로 만든 해시 코드만 정의할 수 있다면 해시 인덱스를 사용할 수 있다.
그렇다면 문자 뿐만 아니라 내가 직접 만든 `Member` , `User` 와 같은 객체는 어떻게 해시 코드를 정의할 수 있을까?

자바의 `hashCode()` 메서드에 대해 알아보자.

**자바의 hashCode()
해시 인덱스를 사용하는 해시 자료 구조는 데이터 추가, 검색, 삭제의 성능이 O(1)로 매우 빠르다.
따라서 많은 곳에서 자주 사용된다. 그런데 앞서 학습한 것 처럼 해시 자료 구조를 사용하려면 정수로 된 숫자 값인 해시 코드가 필요하다.
자바에는 정수 `int` , `Integer` 뿐만 아니라 `char` , `String` , `Double` , `Boolean` 등 수 많은 타입이 있다.
뿐만 아니라 개발자가 직접 정의한 `Member` , `User` 와 같은 사용자 정의 타입도 있다.
이 모든 타입을 해시 자료 구조에 저장하려면 모든 객체가 숫자 해시 코드를 제공할 수 있어야 한다.


**Object.hashCode()
자바는 모든 객체가 자신만의 해시 코드를 표현할 수 있는 기능을 제공한다.
바로 `Object` 에 있는 `hashCode()` 메서드이다.

public class Object
{
public int hashCode();
}
```

이 메서드를 그대로 사용하기 보다는 보통 재정의(오버라이딩)해서 사용한다.
이 메서드의 기본 구현은 객체의 참조값을 기반으로 해시 코드를 생성한다.
쉽게 이야기해서 객체의 인스턴스가 다르면 해시 코드도 다르다.


Object의 해시 코드 비교
`Object` 가 기본으로 제공하는 `hashCode()` 는 객체의 참조값을 해시 코드로 사용한다. 따라서 각각의 인스턴스마다 서로 다른 값을 반환한다.
그 결과 `obj1` , `obj2` 는 서로 다른 해시 코드를 반환한다.

자바의 기본 클래스의 해시 코드
`Integer` , `String` 같은 자바의 기본 클래스들은 대부분 내부 값을 기반으로 해시 코드를 구할 수 있도록
`hashCode()` 메서드를 재정의해 두었다.
따라서 데이터의 값이 같으면 같은 해시 코드를 반환한다.
해시 코드의 경우 정수를 반환하기 때문에 마이너스 값이 나올 수 있다.

동일성과 동등성 복습
잠깐 동일성과 동등성에서 학습한 내용을 복습해보자.
`Object` 는 동등성 비교를 위한 `equals()` 메서드를 제공한다.
자바는 두 객체가 같다는 표현을 2가지로 분리해서 사용한다.

**동일성(Identity)**: `
==
` 연산자를 사용해서 두 객체의 참조가 동일한 객체를 가리키고 있는지 확인

**동등성(Equality)**: `equals()` 메서드를 사용하여 두 객체가 논리적으로 동등한지 확인
쉽게 이야기해서 동일성(Identity)은 물리적으로 같은 메모리에 있는 객체인지 참조값을 확인하는 것이고, 동등성은 논리적으로 같은지 확인하는 것이다.
동일성은 자바 머신 기준이고 메모리의 참조가 기준으로 물리적이다.
동등성은 보통 사람이 생각하는 논리적인 것에 기준을 맞춘다. 따라서 논리적이다.
동등성은 예를 들면 같은 회원 번호를 가진 회원 객체가 2개 있다고 가정해보자.

```java
```
User a = new User("id-100")
User b = new User("id-100")

이런 경우 물리적으로 다른 메모리에 있는 객체이지만, 논리적으로는 같다고 표현할 수 있다.
따라서 동일성은 다르지만, 동등성은 같다.
문자의 경우도 마찬가지이다.


```java
```
String s1 = new String("hello");
String s2 = new String("hello");

이 경우 물리적으로는 각각의 "hello" 문자열이 다른 메모리에 존재할 수 있지만, 논리적으로는 같은 `"hello"` 라는 문자열이다.


**직접 구현하는 해시 코드
`Member` 의 경우 회원의 `id` 가 같으면 논리적으로 같은 회원으로 표현할 수 있다. 따라서 회원 `id` 를 기반으로 동등성 비교하도록 `equals` 를 재정의해야 한다.
여기에 `hashCode()`도 같은 원리가 적용된다. 회원의 `id` 가 같으면 논리적으로 같은 회원으로 표현할 수 있다.
따라서 회원 `id` 를 기반으로 해시 코드를 생성해야 한다.

**Member의 hashCode() 구현**
`Member` 는 `hashCode()` 를 재정의했다.
`hashCode()` 를 재정의할 때 `Objects.hash()` 에 해시 코드로 사용할 값을 지정해주면 쉽게 해시 코드를 생성할 수 있다.
`hashCode()` 를 재정의하지 않으면 `Object` 가 기본으로 제공하는 `hashCode()` 를 사용하게 된다. 이것은 객체의 참조값을 기반으로 해시 코드를 제공한다.
따라서 회원의 `id` 가 같아도 인스턴스가 다르면 다른 해시 코드를 반환하게 된다.
`hashCode()` 를 `id` 를 기반으로 재정의한 덕분에 인스턴스가 달라도 `id` 값이 같으면 같은 해시 코드를 반환한다.
따라서 인스턴스가 다른 `member1` , `member2` 둘다 같은 해시 코드를 반환하는 것을 확인할 수 있다.

**정리**
자바가 기본으로 제공하는 클래스 대부분은 `hashCode()` 를 재정의해두었다.
객체를 직접 만들어야 하는 경우에 `hashCode()` 를 재정의하면 된다.
`hashCode()` 만 재정의하면 필요한 모든 종류의 객체를 해시 자료 구조에 보관할 수 있다.
정리하면 해시 자료 구조에 데이터를 저장하는 경우 `hashCode()` 를 구현해야 한다.
이제 `hashCode()` 를 사용해서 모든 데이터 타입을 저장할 수 있는 `MyHashSetV2` 를 만들어보자.