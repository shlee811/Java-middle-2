<제네릭 용어와 관례>
제네릭의 핵심은 **사용할 타입을 미리 결정하지 않는다는 점**이다.
클래스 내부에서 사용하는 타입을 클래스를 정의하는 시점에 결정하는 것이 아니라 실제 사용하는 생성 시점에 타입을 결정하는 것이다.
이것을 쉽게 비유하자면 메서드의 매개변수와 인자의 관계와 비슷하다.

**메서드에 필요한 값을 메서드 정의 시점에 미리 결정**
```java
void method1() {
println("hello");
}
```
메서드에 필요한 값을 이렇게 메서드 정의 시점에 미리 결정하게 되면, 이 메서드는 오직 `"hello"` 라는 값만 출력할 수 있다. 따라서 재사용성이 떨어진다.

**메서드에 필요한 값을 인자를 통해 매개변수로 전달해서 결정**
```java
void method2(String param) {
println(param);
}
void main() {
method2("hello");
method2("hi");
}
```
-메서드에 필요한 값을 메서드를 정의하는 시점에 미리 결정하는 것이 아니라, 메서드를 실제 사용하는 시점으로 미룰 수 있다.
-메서드에 매개변수(`String param` )를 지정하고, 매서드를 사용할 때 원하는 값을 인자(`"hello"` , `"hi"` )로 전달하면 된다.

**다양한 값을 처리하는 메서드**
```java
//method2("hello") 호출 예
void method2(String param="hello") {
println(param);
}

//method2("hi") 호출 예
void method2(String param="hi") {
println(param);
}
```
매개변수를 정의하고, 실행 시점에 인자를 통해 원하는 값을 매개변수에 전달했다.
이렇게 하면 이 메서드는 실행 시점에 얼마든지 다른 값을 받아서 처리할 수 있다. 따라서 재사용성이 크게 늘어난다.

**메서드의 매개변수와 인자**
```java
void method(String param) //매개변수
void main() {
String arg = "hello";
method(arg) //인수 전달
}
```
매개변수(Parameter): `String param`인자, 인수(Argument): `arg` 메서드의 매개변수에 인자를 전달해서 메서드의 사용 값을 결정한다.

**제네릭의 타입 매개변수와 타입 인자**
제네릭도 앞서 설명한 메서드의 매개변수와 인자의 관계와 비슷하게 작동한다.
제네릭 클래스를 정의할 때 내부에서 사용할 타입을 미리 결정하는 것이 아니라, 해당 클래스를 실제 사용하는 생성 시점에 내부에서 사용할 타입을 결정하는 것이다.
차이가 있다면 **메서드의 매개변수는 사용할 값에 대한 결정을 나중으로 미루는 것**이고, **제네릭의 타입 매개변수는 사용할 타입에 대한 결정을 나중으로 미루는 것**이다.

정리하면 다음과 같다.
메서드는 **매개변수**에 **인자**를 전달해서 사용할 값을 결정한다.
제네릭 클래스는 **타입 매개변수**에 **타입 인자**를 전달해서 사용할 타입을 결정한다.
제네릭에서 사용하는 용어도 매개변수, 인자의 용어를 그대로 가져다 사용한다. 다만 값이 아니라 **타입을 결정**하는 것이기 때문에 앞에 타입을 붙인다.

타입 매개변수: `GenericBox<T>` 에서 `T`
타입 인자:
-`GenericBox<Integer>` 에서 `Integer`
-`GenericBox<String>` 에서 `String`

제네릭 타입의 타입 매개변수 `<T>` 에 타입 인자를 전달해서 제네릭의 사용 타입을 결정한다.
`GenericBox<T>`
-`String` `GenericBox<String>`
-`Integer` ` GenericBox<Integer>`

**용어 정리**
**제네릭(Generic) 단어**
제네릭이라는 단어는 일반적인, 범용적인이라는 영어 단어 뜻이다.
풀어보면 특정 타입에 속한 것이 아니라 일반적으로, 범용적으로 사용할 수 있다는 뜻이다.

**제네릭 타입 (Generic Type)**
클래스나 인터페이스를 정의할 때 타입 매개변수를 사용하는 것을 말한다.
제네릭 클래스, 제네릭 인터페이스를 모두 합쳐서 제네릭 타입이라 한다.
타입은 클래스, 인터페이스, 기본형(`int` 등)을 모두 합쳐서 부르는 말이다.
예: `class GenericBox<T> { private T t; }`
여기에서 `GenericBox<T>` 를 제네릭 타입이라 한다.

**타입 매개변수 (Type Parameter)**
제네릭 타입이나 메서드에서 사용되는 변수로, 실제 타입으로 대체된다.
예: `GenericBox<T>`
여기에서 `T` 를 타입 매개변수라 한다.

**타입 인자 (Type Argument)**
제네릭 타입을 사용할 때 제공되는 실제 타입이다.
예: `GenericBox<Integer>`
여기에서 `Integer` 를 타입 인자라 한다.

제네릭 명명 관례
타입 매개변수는 일반적인 변수명처럼 소문자로 사용해도 문제는 없다.
하지만 일반적으로 대문자를 사용하고 용도에 맞는 단어의 첫글자를 사용하는 관례를 따른다.
주로 사용하는 키워드는 다음과 같다.
E - Element
K - Key
N - Number
T - Type
V - Value
S,U,V etc. - 2nd, 3rd, 4th types
제네릭 기타
다음과 같이 한번에 여러 타입 매개변수를 선언할 수 있다.
```java
```
class Data<K, V> {}
**타입 인자로 기본형은 사용할 수 없다**
제네릭의 타입 인자로 기본형(`int` , `double` ..)은 사용할 수 없다. 대신에 래퍼 클래스(`Integer` , `Double` )를 사용하면 된다.

<와일드카드1>
이번에는 제네릭 타입을 조금 더 편리하게 사용할 수 있는 와일드카드(wildcard)에 대해 알아보자.
참고로 와일드카드라는 뜻은 컴퓨터 프로그래밍에서 `*` , `?` 와 같이 하나 이상의 문자들을 상징하는 특수 문자를 뜻한다.
쉽게 이야기해서 여러 타입이 들어올 수 있다는 뜻이다.


<와일드카드2>
**상한 와일드카드**
```java
static <T extends Animal> void printGenericV2(Box<T> box) {
    T t = box.get();
    System.out.println("이름 = " + t.getName());
}

static void printWildcardV2(Box<? extends Animal> box) {
    Animal animal = box.get();
    System.out.println("이름 = " + animal.getName());
}
```
제네릭 메서드와 마찬가지로 와일드카드에도 상한 제한을 둘 수 있다.
여기서는 `? extends Animal` 을 지정했다. `Animal` 과 그 하위 타입만 입력 받는다.
만약 다른 타입을 입력하면 컴파일 오류가 발생한다. `box.get()` 을 통해서 꺼낼 수 있는 타입의 최대 부모는 `Animal` 이 된다.
따라서 `Animal` 타입으로 조회할 수 있다. 결과적으로 `Animal` 타입의 기능을 호출할 수 있다.

<타입 매개변수가 꼭 필요한 경우>
와일드카드는 제네릭을 정의할 때 사용하는 것이 아니다.
`Box<Dog>` , `Box<Cat>` 처럼 타입 인자가 전달된 제네릭 타입을 활용할 때 사용한다.
따라서 다음과 같은 경우에는 제네릭 타입이나 제네릭 메서드를 사용해야 문제를 해결할 수 있다.

메서드의 타입들을 특정 시점에 변경하려면 제네릭 타입이나, 제네릭 메서드를 사용해야 한다.
와일드카드는 이미 만들어진 제네릭 타입을 전달 받아서 활용할 때 사용한다. 따라서 메서드의 타입들을 타입 인자를 통해 변경할 수 없다.
쉽게 이야기해서 일반적인 메서드에 사용한다고 생각하면 된다.
정리하면 제네릭 타입이나 제네릭 메서드가 꼭 필요한 상황이면 `<T>` 를 사용하고, 그렇지 않은 상황이면 와일드카드를 사용하는 것을 권장한다.


<타입 이레이저>
이레이저(erasere)는 지우개 등으로 지우다라는 뜻이다.
제네릭은 자바 컴파일 단계에서만 사용되고, 컴파일 이후에는 제네릭 정보가 삭제된다.
제네릭에 사용한 타입 매개변수가 모두 사라지는 것이다.
쉽게 이야기해서 컴파일 전인 `.java` 에는 제네릭의 타입 매개변수가 존재하지만, 컴파일 이후인 자바 바이트코드 `.class` 에는 타입 매개변수가 존재하지 않는 것이다.
어떻게 변하게 되는지 다음 코드로 설명하겠다. 100% 정확한 코드는 아니고 대략 이런 방식으로 작동한다고 이해하면 충분하다.